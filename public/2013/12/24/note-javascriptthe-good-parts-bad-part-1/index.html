<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>[筆記] Javascript : The Good Parts - 糟糕的部分 | It&#39;s just works!</title>
  <meta name="author" content="EijiHsu">

  
  <meta name="description" content="全域變數
javascript最糟糕的一項特性，就是他對於全域變數的依賴。有三種可以宣告全域變數的方式：
123var foo = &#39;value&#39;; // 直接在最外層宣告window.foo = &#39;value&#39; // window物件是所有全域變數的容器foo = &#39;value&#39; // 不經宣告就使用變數，稱為implied global

第三種原本的用意是對於初學者的體貼（蛤？），但這反而容易造成很難被找出來的bug。
範圍
如同前面提到的，javascript沒有block scope，只有function scope，而且裡面還有變數抬升的特性。所以最好 在每個區塊起始的地方宣告完區塊內所有變數 。
分號的安插
javascript有個試圖糾正錯誤的機制，它會自動幫你安插分號。不過這個機制有時候會造成更多的麻煩：
1234return{	status: true;};

上面的程式看起來很正常，不過javascript會認為你return後面忘了加上分號而貼心的幫你補上，於是就變成這樣：
1234return; // undefind{	status: true;};

所以撰寫javascript時應該採用K&amp;amp;R風格，把{放在句尾，可以避免類似的悲劇發生。">
  
  

  <link rel="alternate" href="/atom.xml" title="It&#39;s just works!" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
  
</head>

<body>
  <header id="header" class="inner"><nav>
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
</nav></header>
  <div id="content" class="inner"><article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <header>
    
  
    <h1 class="title">[筆記] Javascript : The Good Parts - 糟糕的部分</h1>
  

    <time datetime="2013-12-24T00:44:00.000Z">
  <span class="day">24</span><span class="month">12月</span>
</time>
  </header>
  <div class="entry-content">
    
      <h2 id="全域變數">全域變數</h2>
<p>javascript最糟糕的一項特性，就是他對於全域變數的依賴。有三種可以宣告全域變數的方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="string">'value'</span>; <span class="comment">// 直接在最外層宣告</span></div><div class="line"><span class="built_in">window</span>.foo = <span class="string">'value'</span> <span class="comment">// window物件是所有全域變數的容器</span></div><div class="line">foo = <span class="string">'value'</span> <span class="comment">// 不經宣告就使用變數，稱為implied global</span></div></pre></td></tr></table></figure>

<p>第三種原本的用意是對於初學者的體貼（蛤？），但這反而容易造成很難被找出來的bug。</p>
<h2 id="範圍">範圍</h2>
<p>如同前面提到的，javascript沒有block scope，只有function scope，而且裡面還有變數抬升的特性。所以最好 <strong>在每個區塊起始的地方宣告完區塊內所有變數</strong> 。</p>
<h2 id="分號的安插">分號的安插</h2>
<p>javascript有個試圖糾正錯誤的機制，它會自動幫你安插分號。不過這個機制有時候會造成更多的麻煩：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span></div><div class="line">{</div><div class="line">	status: <span class="literal">true</span>;</div><div class="line">};</div></pre></td></tr></table></figure>

<p>上面的程式看起來很正常，不過javascript會認為你<code>return</code>後面忘了加上分號而貼心的幫你補上，於是就變成這樣：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span>; <span class="comment">// undefind</span></div><div class="line">{</div><div class="line">	status: <span class="literal">true</span>;</div><div class="line">};</div></pre></td></tr></table></figure>

<p>所以撰寫javascript時應該採用K&amp;R風格，把<code>{</code>放在句尾，可以避免類似的悲劇發生。<br><a id="more"></a></p>
<h2 id="保留字">保留字</h2>
<p>作者認為有太多的保留字沒有被使用，造成命名上的麻煩（保留字不能用在變數或特性名稱）</p>
<blockquote>
<p>不過事實上，有一些是後來實作ECMA5有用到的</p>
</blockquote>
<h2 id="Unicode">Unicode</h2>
<p>在設計javascript的年代，Unicode最多只到65536個字元，但現在已經突破百萬。<br>javascript的字元是16位元，超出的部分以一對字元表示。Unicode把 <strong>字元對</strong> 當成一個字元，但對javascript來說是兩個。</p>
<h2 id="typeof">typeof</h2>
<p>typeof有許多非預期的狀況，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// object</span></div><div class="line"><span class="keyword">typeof</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="comment">// object</span></div><div class="line"><span class="keyword">typeof</span> /a/ <span class="comment">// 各瀏覽器實作不一致，可能是object或function</span></div></pre></td></tr></table></figure>

<h2 id="parseInt">parseInt</h2>
<p><code>parseInt</code>是個把字串轉換為整數的函式，他會在遇到非數字字元的時候立即停止，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">parseInt</span>(<span class="string">'16 say hi~ 17'</span>); <span class="comment">// 16</span></div></pre></td></tr></table></figure>

<p>這函式還有另一個麻煩，如果字串的第一個字元是0，字串會依照八進位制做轉換，所以最好在每次使用時都帶入進位參數：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">parseInt</span>(<span class="string">'077'</span>); <span class="comment">// 63</span></div><div class="line"><span class="built_in">parseInt</span>(<span class="string">'077'</span>, <span class="number">10</span>); <span class="comment">// 77</span></div></pre></td></tr></table></figure>

<blockquote>
<p>這點似乎在新版的Browser有fix過，沒有帶入參數就默認10進位</p>
</blockquote>
<h2 id="+運算子">+運算子</h2>
<p>如果你希望 + 運算子是sum的作用，務必要檢查兩邊是不是”都是”數字。</p>
<h2 id="浮點數">浮點數</h2>
<p>這是最常被回報的bug。javascript採用<a href="http://zh.wikipedia.org/wiki/IEEE_754" target="_blank" rel="external">IEEE754標準</a>，導致他在處理十進位分數的時候會發生一些問題，例如：</p>
<figure class="highlight JS"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="number">0.1</span> + <span class="number">0.2</span>); <span class="comment">// 0.30000000000000004</span></div></pre></td></tr></table></figure>

<p>幸好，在整數運算的部分是正確的，所以可以先換成整數做運算在除回來。</p>
<h2 id="NaN">NaN</h2>
<p>這也是個奇妙的東西，它的意義是＂非數值(not an number)＂，不過…</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span> === <span class="string">'number'</span>; <span class="comment">// true</span></div></pre></td></tr></table></figure>

<p>還有更奇妙的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span> <span class="comment">// false</span></div><div class="line"><span class="literal">NaN</span> !== <span class="literal">NaN</span> <span class="comment">// true</span></div></pre></td></tr></table></figure>

<p>這哪招阿…<br>幸好javascript有提供一個檢查<code>NaN</code>的函式：</p>
<figure class="highlight JS"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>); <span class="comment">// true</span></div><div class="line"><span class="built_in">isNaN</span>(<span class="number">0</span>); <span class="comment">// false</span></div><div class="line"><span class="built_in">isNaN</span>(<span class="string">'hi~'</span>); <span class="comment">// true</span></div><div class="line"><span class="built_in">isNaN</span>(<span class="string">'0'</span>); <span class="comment">// false</span></div></pre></td></tr></table></figure>

<blockquote>
<p>這方法有點兩光阿…要檢查NaN還是得判斷兩次才行Orz</p>
</blockquote>
<p>還有一個<code>isFinite</code>函式，可以判斷＂值是否可以轉成數值＂，他會拒絕<code>NaN</code>跟<code>Infinity</code>。如果要確認值＂是不是數值(<code>number</code>)＂的話，需要自己加工：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> isNumber = <span class="function"><span class="keyword">function</span><span class="params">(value)</span></span>{</div><div class="line">	<span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">'number'</span> && <span class="built_in">isFinite</span>(value);</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="偽陣列">偽陣列</h2>
<p>前面提過，javascript沒有真正的陣列，而是基於物件的偽陣列。跟真正的陣列相比，他的效能較差，但較容易使用。也因為這個特性的關係，<code>typeof</code>運算子沒有辦法區分物件跟陣列。為了判斷是否為陣列，需要把他的Constructor列入考慮：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(myValue && <span class="keyword">typeof</span> myValue === <span class="string">'object'</span> </div><div class="line">		&& myValue.constructor === <span class="built_in">Array</span>){</div><div class="line">  <span class="comment">//muValue is Array!</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果陣列在不同的frame或window下建立，上面的測試可能給出false, 可以改成下面的形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(myValue && <span class="keyword">typeof</span> myValue === <span class="string">'object'</span> </div><div class="line">    && <span class="keyword">typeof</span> myValue.length === <span class="string">'number'</span></div><div class="line">    && !(myValue.propertyIsEnumberable(<span class="string">'length'</span>))){</div><div class="line">  <span class="comment">//muValue is Array!</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>另外，<code>arguments</code>並不是個陣列，而是個具有length的物件，但上述測試會把它視為陣列；有時候我們會想要這種結果。</p>
<h2 id="False類的值">False類的值</h2>
<p>下面這些的值會被歸類在false：</p>
<ul>
<li>0                  (number)</li>
<li>NaN              (number)</li>
<li>‘’                 (String)</li>
<li>false          (Boolean)</li>
<li>null           (Object)</li>
<li>undefind  (undefind)</li>
</ul>
<p>undefind跟NaN不是常數而是全域變數，可以去更改他們的值。應該不能這樣做，但真的可以。請千萬別這樣做。</p>
<blockquote>
<p>剛剛試了一下，這好像也會被Browser Fix掉…真可惜（喂！）</p>
</blockquote>
<h2 id="‘hasOwnProperty’">‘hasOwnProperty’</h2>
<p><code>hasOwnProperty</code>是個方法而非運算子，所以他有可能被覆蓋掉。（應該不會有人這麼白目吧？）</p>
<h2 id="物件">物件</h2>
<p>Javascript的物件從未真正為空，因為他們可以從prototype chain取得成員。下面是一個計算詞彙出現次數的範例:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i;</div><div class="line"><span class="keyword">var</span> word;</div><div class="line"><span class="keyword">var</span> text = <span class="string">"...some words and constructor"</span></div><div class="line"><span class="keyword">var</span> words = text.toLowerCase().split(<span class="regexp">/[\s,.]+/</span>);</div><div class="line"><span class="keyword">var</span> count = {};</div><div class="line"></div><div class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; words.length; i += <span class="number">1</span>){</div><div class="line">	word = words[i];</div><div class="line">  <span class="keyword">if</span>(count[word]){</div><div class="line">  	count[word] += <span class="number">1</span>;</div><div class="line">  } <span class="keyword">else</span> {</div><div class="line">  	count[word] = <span class="number">1</span>;</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>count[constructor]會包含一串很長的字串（chrome是顯示<code>&quot;function Object() { [native code] }1&quot;</code>），因為count物件繼承Object.prototype，裡面也有一個constructor特性，他被轉成String然後在尾端加上1。所以應該跟for-in時一樣，用<code>hasOwnProperty</code>方法做檢查。</p>

    
    
    <footer class="meta">
      
  <div class="cats">
<a href="/categories/javascript/">javascript</a><a href="/categories/javascript/筆記/">筆記</a></div>

      
      
    </footer>
    
  </div>
  
</article></div>
  <footer id="footer" class="inner"><div class="social alignright">
  
  
  
  
  <a class="rss" href="/atom.xml" title="RSS">RSS</a>
</div>
<p>
  
  &copy; 2015 EijiHsu
  
</p>
<div class="clearfix"></div></footer>
  <script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<div id="phasebeam">
  <canvas></canvas>
  <canvas></canvas>
  <canvas></canvas>
</div>
<script src="/js/phasebeam.js"></script>
</body>
</html>