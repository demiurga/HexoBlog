<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>[筆記] 關於載入Script | It&#39;s just works!</title>
  <meta name="author" content="EijiHsu">

  
  <meta name="description" content="最近在看Javascript Patterns這本書，剛好這陣子有碰到比較大的js data，就把書中一些關於Script讀取策略的部分整理一下。
Script Tag的屬性

language這個屬性有各種不同大小寫的格式，像是：JavaScript, javascript, Javascript，有時候還附帶版本號。但其實根本就不應該用這個屬性，因為預設語言就是JavaScript，版本號也運作得不好。

註：W3C已經不推薦使用這個屬性

typeHTML4跟XHAML1標準會驗證這個屬性為必要，但其實不應該如此，因為預設就是JavaScript。HTML5已經將這個屬性改成非必要。
defer這段指定的Script會在頁面Render結束之後才運作，HTML5有更方便的async屬性。

async跟defer的區別在於前者是在ParseDOM時載入Script並在載入完成後執行，後者則是在頁面載入結束後載入Script，並在載入完成後執行。一個小技巧是同時放上async跟defer，支援async的瀏覽器會忽略defer，不支援的則會使用defer。關於defer這個屬性，其實各瀏覽器實作的方式不一樣，許多現代瀏覽器，例如Chrome，預設就是在頁面Render結束後才載入&amp;lt;head&amp;gt;中有src的&amp;lt;scripe&amp;gt;。這篇文章有作一些測試。

放置Script Tag的位置

&amp;lt;script&amp;gt;標籤會阻擋在他之後的事件，包括頁面render或下載，所以放置&amp;lt;Script&amp;gt;最好的位置是在&amp;lt;/body&amp;gt;之前，這樣可以防止頁面載入被Scrtpt標籤阻擋而拖延。最差的方式則是在&amp;lt;head&amp;gt;中引入多個獨立的檔案，會佔去server許多不必要的連線數。

個人經驗，有沒有pack成單一檔案對伺服器負載能力真的差蠻多的">
  
  

  <link rel="alternate" href="/atom.xml" title="It&#39;s just works!" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
  
</head>

<body>
  <header id="header" class="inner"><nav>
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
</nav></header>
  <div id="content" class="inner"><article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <header>
    
  
    <h1 class="title">[筆記] 關於載入Script</h1>
  

    <time datetime="2014-01-17T01:02:00.000Z">
  <span class="day">17</span><span class="month">1月</span>
</time>
  </header>
  <div class="entry-content">
    
      <p>最近在看<a href="http://www.tenlong.com.tw/items/9862764198?item_id=427729" target="_blank" rel="external">Javascript Patterns</a>這本書，剛好這陣子有碰到比較大的js data，就把書中一些關於Script讀取策略的部分整理一下。</p>
<h2 id="Script_Tag的屬性">Script Tag的屬性</h2>
<hr>
<p><code>language</code><br>這個屬性有各種不同大小寫的格式，像是：<code>JavaScript</code>, <code>javascript</code>, <code>Javascript</code>，有時候還附帶版本號。但其實根本就不應該用這個屬性，因為預設語言就是JavaScript，版本號也運作得不好。</p>
<blockquote>
<p>註：W3C已經不推薦使用這個屬性</p>
</blockquote>
<p><code>type</code><br>HTML4跟XHAML1標準會驗證這個屬性為必要，但其實不應該如此，因為預設就是JavaScript。HTML5已經將這個屬性改成非必要。</p>
<p><code>defer</code><br>這段指定的Script會在頁面Render結束之後才運作，HTML5有更方便的<code>async</code>屬性。</p>
<blockquote>
<p>async跟defer的區別在於前者是在ParseDOM時載入Script並在載入完成後執行，後者則是在頁面載入結束後載入Script，並在載入完成後執行。一個小技巧是同時放上<code>async</code>跟<code>defer</code>，支援async的瀏覽器會忽略defer，不支援的則會使用defer。<br>關於<code>defer</code>這個屬性，其實各瀏覽器實作的方式不一樣，許多現代瀏覽器，例如Chrome，預設就是在頁面Render結束後才載入<code>&lt;head&gt;</code>中有<code>src</code>的<code>&lt;scripe&gt;</code>。<a href="http://mao.li/javascript/javascript-defer/" target="_blank" rel="external">這篇文章</a>有作一些測試。</p>
</blockquote>
<h2 id="放置Script_Tag的位置">放置Script Tag的位置</h2>
<hr>
<p><code>&lt;script&gt;</code>標籤會阻擋在他之後的事件，包括頁面render或下載，所以放置<code>&lt;Script&gt;</code>最好的位置是在<code>&lt;/body&gt;</code>之前，這樣可以防止頁面載入被Scrtpt標籤阻擋而拖延。最差的方式則是在<code>&lt;head&gt;</code>中引入多個獨立的檔案，會佔去server許多不必要的連線數。</p>
<blockquote>
<p>個人經驗，有沒有pack成單一檔案對伺服器負載能力真的差蠻多的</p>
</blockquote>
<a id="more"></a>
<h2 id="HTTP分塊">HTTP分塊</h2>
<hr>
<p>HTTP協定支援分塊編碼，意思是你可以分批傳送頁面的片段。如果有一個非常複查的頁面，可以用像下面這種方法來分批傳送：</p>
<figure class="highlight HTML"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="doctype">&lt;!doctype html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">head</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">title</span>&gt;</span>My App<span class="tag">&lt;/<span class="title">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"header"</span>&gt;</span></div><div class="line">  	<span class="comment">&lt;!-- content1, like logo --&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="title">div</span>&gt;</span></div><div class="line">  // block1 end</div><div class="line">  <span class="comment">&lt;!-- content2, main content --&gt;</span></div><div class="line">  // block2 end</div><div class="line">  <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"main.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></div><div class="line">// block3 end</div></pre></td></tr></table></figure>

<p>先在第一區塊傳入部分標頭和主體，第二區塊傳入主要內容，第三區塊再傳入js檔為頁面添加特色和互動。這種作法十分符合漸進式增強和unobtrusive javascript的精神。</p>
<h2 id="動態載入">動態載入</h2>
<hr>
<p>要避免頁面render被script tag拖慢的問題，有下面幾種方法：</p>
<ul>
<li>用XHR請求來下載script，並用<code>eval()</code>來執行。不要這樣做。</li>
<li>用<code>defer</code>和<code>async</code>屬性，但是有跨瀏覽器的問題。</li>
<li>動態載入<code>&lt;script&gt;</code>元素   </li>
</ul>
<p>最後一種模式是個不錯的方法，像下面這樣：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.creatElement(<span class="string">'script'</span>);</div><div class="line">script.src = <span class="string">'Main.js'</span>;</div><div class="line"><span class="built_in">document</span>.documentElement.firstChild.appendChild(script);</div></pre></td></tr></table></figure>

<p>上面簡單的產生了一個script元素，並把他append到<code>&lt;head&gt;</code>內。這種方法要注意順序的問題，可以用一個initScriptsArray來解決他：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> initScripts = [],</div><div class="line">		init = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">    	<span class="comment">// for loop initScripts</span></div><div class="line">    };</div><div class="line">initScripts.push(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">	<span class="comment">// some script</span></div><div class="line">});</div></pre></td></tr></table></figure>

<p>動態載入有很多應用方法，例如把它放到<code>&lt;/body&gt;</code>前，確保使用者能先確認頁面的靜態內容，並趁這個時候載入互動相關的script，這種方法稱為lazy load（延遲載入）。或是依每個頁面行為或裝置的不同來分塊載入script，例如在mobile上部分較耗資源的效果可能會被停用，這時就可以不必載入那段script，這種方法稱為require load（隨選載入）。也可以在這一頁就預先載入下一頁需要的script，稱為preload（預先載入），不過使用這種方法必須注意，要讓預載的檔案只載入但不分析執行，因為不存在的DOM（下一頁的DOM）可能會造成錯誤。</p>
<p>要下載一段script但不進行分析，可以用<code>&lt;object&gt;</code>元素來代替<code>&lt;script&gt;</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = <span class="built_in">document</span>.creatElement(<span class="string">'object'</span>);</div><div class="line">obj.data = <span class="string">'preload.js'</span>;</div><div class="line"><span class="comment">// 用data屬性代替src</span></div><div class="line"><span class="built_in">document</span>.body.appendChild(<span class="string">'obj'</span>);</div></pre></td></tr></table></figure>

<blockquote>
<p>書上有提到用image beacon的方式來處理IE，不過我找不到IE跟<code>&lt;object&gt;</code>之間發生了什麼事，為什麼要用Image beacon來處理這件事…</p>
</blockquote>
<p>預先載入模式可以套用各種類型的元件，例如圖片或影音檔案，主要用在可以預期使用者下一個行為的時候。例如在輸入帳號密碼時，就可以對登入後的頁面進行部分預載。</p>

    
    
    <footer class="meta">
      
      
      
    </footer>
    
  </div>
  
</article></div>
  <footer id="footer" class="inner"><div class="social alignright">
  
  
  
  
  <a class="rss" href="/atom.xml" title="RSS">RSS</a>
</div>
<p>
  
  &copy; 2015 EijiHsu
  
</p>
<div class="clearfix"></div></footer>
  <script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<div id="phasebeam">
  <canvas></canvas>
  <canvas></canvas>
  <canvas></canvas>
</div>
<script src="/js/phasebeam.js"></script>
</body>
</html>